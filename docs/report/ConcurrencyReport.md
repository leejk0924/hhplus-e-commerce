# 동시성 이슈 분석 및 해결에 대한 보고서

## Abstract
동시성 제어는 다수의 요청이 하나의 자원에 접근하여 읽기, 쓰기 작업을 할때 발생하는 문제를 해결하여, 데이터의 일관성과 무결성을 유지하는 역할을 한다.
본 보고서에서는 현재 진행중인 E-commerce 프로젝트에서 나타날 수 있는 동시성 이슈에 대해 알아보고, 이러한 문제를 해결해보는 방식으로 동시성 이슈에 대한 이해를 높이고자 한다. 

## 동시성 제어란
여러 트랜잭션이 동일한 데이터에 **동시 접근 시**, 데이터 무결성 및 일관성을 지키기 위한 기법입니다.

동시성 제어를 처리하지 않으면 다음과 같은 문제가 발생할 수 있다.
- Lost Update : 여러 트랜잭션이 동시에 공유 데이터를 수정할 때, 서로 데이터를 덮어쓰다가 맨 마지막 커밋이 적용되는 현상 (READ COMMITTED 이하)
- Dirty Read : 커밋되지 않은 트랜잭션의 변경을 다른 트랜잭션이 읽는 현상 (해당 트랜잭션이 롤백 될 경우 다른 트랜잭션이 읽은 값이 잘못되기 떄문에)
- Non-Repeatable Read : 트랜잭션 내에서 동일 쿼리를 반복하여 수행할 때 다른 결과를 가져오는 현상
- Phantom Read : A 트랜잭션이 레코드를 조회 -> B 트랜잭션이 새로운 레코드 삽입 -> A 트랜잭션이 동일한 조건으로 재 조회 시 레코드 수가 달라지는 현상 (REPEATABLE READ 이하)

이러한 문제는 애플리케이션, DB, 비즈니스 관점에서 각각 다음과 같은 방법으로 해결할 수 있다.
- 애플리케이션에서 `synchronized`/`Lock`/`volatile` 등을 통해 메모리 가시성과 원자성을 보장할 수 있다.
- DB에서 적절한 트랜잭션 격리 수준과 Lock으로 해결할 수 있다.
- 비즈니스 관점에서 트랜잭션 경계와 retry을 통해 데이터 일관성을 확보할 수 있다.

## Database Lock을 통한 해결방안
Database Lock은 여러 트랜잭션이 동시에 데이터에 접근할 때 충돌을 방지하고 정합성을 보장하기 위한 메커니즘이다.

#### 동시성 제어를 위한 Lock 전략
🔒낙관적락 (Optimistic Lock)
데이터의 충돌이 드물게 일어날 것이라고 가정하는 방식이다. 동작방식은 아래와 같다.
- 데이터를 읽을 떄는 락을 걸지 않는다.
- 버전 번호나 타임스탬프를 사용해 데이터 변경을 추적한다.
- 업데이트 시점에 데이터가 변경되었는지 확인한다.

장점: 
- 높은 동시성을 제공한다.
- 읽기 성능이 좋다.

단점: 
- 충돌 시 재시도 로직이 필요하다.
- 충돌할 확률이 높은 환경에서는 오히려 비효율적이다.

🔒비관적락 (Pessimistic Lock)
충돌이 자주 일어날 것을 가정하는 방식이다. 동작방식은 아래와 같다.
- 데이터를 읽는 시점에 즉시 락을 획득
- 트랜잭션이 완료될 때 까지 다른 트랜잭션의 접근을 완전히 차단한다.

장점:
- 데이터 충돌을 확실히 방지
- 충돌이 많은 환경에서 효율적이다.

단점: 
- 성능이 낙관적락에 비해 떨어진다. (대기 시간 발생)
- 데드락 가능성이 있다.


#### 락의 모드
📌 공유락 (Shared, S-lock)
- 여러 트랜잭션이 동시에 읽기 가능
- 다른 트랜잭션에서의 공유락은 허용하지만, 배타락은 허용하지 않는다.

📌 배타락 (Exclusive, X-lock)
- 다른 트랜잭션이 해당 락이 걸린 레코드에 읽기, 쓰기가 불가
- 다른 트랜잭션에서 공유락과 배타락을 허용하지 않는다.

#### MySQL InnoDB의 기능별 사용하는 Lock
1. 일반 SELECT (Consistent Nonlocking Reads)
- 기본적으로 MVCC 기반의 일관된 읽기(consistent read)를 사용하므로, 실제 데이터 페이지에 락을 걸지 않는다.
- 단, 트랜잭션 격리 수준이 SERIALIZABLE일 경우 조회 과정에서 공유 넥스트-키 락(Shared Next-Key Lock)이 설정된다.

2. SELECT ... FOR UPDATE / LOCK IN SHARE MODE
- FOR UPDATE : 스캔된 레코드에 배타적 잠금(X-lock)을 설정
- LOCK IN SHARE MODE : 스캔된 레코드에 공유 잠금(S-lock)을 설정

3. UPDATE/DELETE
- 쿼리 처리중 스캔되는 모든 인덱스 레코드에 배타적 넥스트-키 락(Next-Key X-lock)을 건다.
- 단일 행을 고유 인덱스로 찾을 경우 해당 인덱스 레코드에 배타적 잠금(X-lock)을 걸다.

4. INSERT
- 새로 삽입되는 레코드에만 인덱스 레코드 잠금(X-lock)을 설정한다.

## 동시성 제어 방식을 결정하는 기준
- 기능별 락의 전략을 구분하는 것이 아닌, 동일한 자원에 대해서는 동일한 락 전략을 사용하고자 한다.
```text
예시 : 포인트 충전과 포인트 차감은 포인트라는 자원에 대해 동일한 락 전략을 적용한다.
```
- 비관적락과 낙관적락의 기준은 충돌 가능성을 기준으로 한다. 충돌가능성이 높을 경우 `비관적락`, 충돌가능성이 적을 경우 `낙관적락`을 사용하고자 한다.

## 문제 발생 구간 & 해결방안
### 1️⃣ 포인트 충전
⭐️문제 발생 구간 
해당 계정의 포인트를 충전할 때 충전 버튼을 연속으로 누를 경우, 덮어쓰기 현상이 나타날 수 있다.

🔨해결방안
포인트 충전은 다른 유저들과의 경쟁이 아닌 특수한 상황 (실수로 버튼을 빠르게 두번 눌렀을 경우)에서 발생하기 때문에, 상대적으로 충돌의 빈도가 적을 것으로 예상됩니다.
그래서 `낙관적락`을 사용하는 것이 적절하다고 판단하였습니다.

구현 예시 : Entity에 version 필드를 추가하고, @Version 을 명시하였다.

```java
    @Version
    @Column(name = "VERSION")
    private Long version;       // 낙관적락을 위한 버전 필드
```

### 2️⃣ 쿠폰 발급
⭐️문제 발생 구간
선착순으로 쿠폰 발급 시 짧은 시간에 많은 유저의 요청을 받게 될 것이고, 이는 덮어쓰기 현상이 나타날 수 있다.

🔨해결방안
짧은 시간에 대량의 트래픽이 발생할 가능성이 높은 상황이며, 요청에 따른 발급 순서 또한 중요한 기능이라 데이터 정합성이 매우 중요할 것으로 예상됩니다.
그래서 `비관적락`을 사용하는 것이 적절하다고 생각합니다.

구현 예시 : 아래와 같이 @Lcok(LockModeType.PESSIMISTIC_WRITE) 을 통해 다른 트랜잭션의 쓰기를 차단하였다.

```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT c FROM COUPON c WHERE c.id = :id")
    Optional<Coupon> findByIdForUpdate(@Param("id") Long id);
```

### 3️⃣ 결제 (재고 차감, 잔액 차감)
⭐️문제 발생 구간
- 결제 시 다른 사용자가 결제 요청 시 음수로 저장되거나, 실제보다 더 많이 판매되는 문제가 발생할 수 있다.
- 포인트 충전과 같이 결제버튼이 두번 연속 눌렸을 경우 동시성 문제가 나타날 것으로 보인다.

🔨해결방안
- 재고 차감 부분의 경우 다른 유저들과의 충돌 가능성도 높고, 먼저 재고 확인 후 해당 재고를 차감해야 하는 등 정확한 재고차감이 중요할 것으로 예상됩니다.
구현 예시 : 쿠폰에서 구현했던 것과 마찬가지로 @Lcok(LockModeType.PESSIMISTIC_WRITE) 을 통해 구현하였다.

```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("""
            SELECT oi FROM ORDER_ITEMS oi WHERE oi.id IN :orderItemIds
            """)
    List<OrderItem> findAllByIdInForUpdate(@Param("orderItemIds") List<Long> orderItemIds);
```

- 잔액 차감의 경우 포인트 충전과 마찬가지로 다른 유저들과의 경쟁이 아닌, 자신에 대한 연속 요청으로 인해 발생하는 경우라고 생각하여, 충돌의 빈도가 적을 것으로 예상됩니다.
- 또한, 잔액 차감은 포인트 충전과 동일한 자원에 대한 락 전략을 사용해야 한다.
- 그래서 재고 차감의 경우 `비관적락`을 사용하고, 잔액 차감은 `낙관적락`을 사용하는 것이 적절하다고 생각했습니다.

## DB 동시성 제어의 한계점
DB 수준의 Lock으로 위에서 발견한 문제점들을 해결할 수 있었다. 하지만, DB락 기반의 동시성 제어는 몇가지 한계점을 가지고 있다.
그래서 상황에 따라 적절한 대안이 필요하다.

### 비즈니스 측면의 한계
동일한 자원이지만 기능이 다른 경우(ex : 포인트 충전/차감), 모두 정합하게 데이터를 반영해야 하는 상황이라면, 낙관적 락으로 제어하기 어렵다.
이러한 상황에서는 멱등키(Idempotency Key)를 활용한다면, 위와 같은 문제를 해결할 수 있다. 

### 순서 보장의 한계
비과적 락을 통해 자원의 동시접근을 막을 순 있지만, 공정성을 보장할 수는 없다. 대부분의 DB의 락은 비공정한 방식으로 동작한다.
공정성이 보장되지 않기 때문에 **선착순**이 의미가 없어질 수 있다.
이러한 경우 DB락이 아닌 메시지 큐 기반의 직렬 처리 방식을 활용한다면, 순서 보장이 되는 공정한 방식으로 문제를 해결할 수 있다.  

### 성능적 한계
비관적 락은 트랜잭션의 시작과 끝까지 자원을 점유하기 때문에, 대용량 트래픽일 경우 병목과 대기현상을 유발한다.
이러한 경우  메시지 큐(Kafka) 또는 분산 락(Redis 등)을 이용한다면 성능적 문제를 해결할 수 있다.

## Conclusion
본 보고서를 통해 동시성 이슈가 무엇인지, 어떤 경우에 동시성 이슈가 발생하는지, 어떻게 해결하는지에 대해 알아보았다.
해당 동시성 이슈를 DB락을 통해 해결했고, 한계점을 경험했다.
충분히 동시성 이슈를 개선 했지만, 이로 인해 나타난 DB 동시성 제어의 한계점 경험했다.
향후 DB락의 한계점을 극복하는 다양한 방식 (멱등키, 메시지 큐, 분산락 등)을 통해 향상된 성능을 갖춘 시스템을 구축할 예정이다.