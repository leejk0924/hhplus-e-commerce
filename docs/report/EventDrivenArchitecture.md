# 이벤트 기반 아키텍처 설계 문서

## Abstract
급증하는 사용자와 트래픽으로 모놀리식 아키텍처는 기능 출시 속도와 확장성, 장애 격리의 한계를 드러낸다.
이에 MSA 전환을 고려하지만, 서비스 경계 분리로 트랜잭션 일관성 범위가 해체되면서 분산 환경 특유의 부분 실패, 중복 처리, 순서 보장, 데이터 일관성 저하 문제가 발생한다.

본 설계 문서에서는 MSA 전환 시 발생할 수 있는 트랜잭션 처리의 한계와 그에 대응하는 방안에 대해 알아보고자 한다.

## MSA란
MSA(MicroService Architecture)는 여러 작은 서비스로 구성되어 각 서비스가 독립적으로 개발·배포 되는 구조이다. 
각 서비스는 명확한 비즈니스에 맞춰 설계되고 독립적인 데이터 관리, 배포, 확장, 장애 복구가 가능하다. 
 
### 장·단점
위의 MSA의 설명만 보면 장점만 있어보인다. 어떤 기술이던 장·단점을 먼저 파악하고, 트레이드오프하여 자신이 적용하고자 하는 서비스에 적합한지 파악을 해야한다.

#### 장점
1. 서비스 단위의 독립성
   - 각 서비스를 독립적으로 운영/배포 할 수 있다. 
     -> 한 서비스를 수정·배포 할 경우, 다른 서비스에 미치는 영향력이 적다.
     -> 서비스가 독립적으로 분리되어 있으므로, 배포시 컴파일 시간이 줄어든다.
2. 확장성
   - 서비스마다 트래픽 특성이 다른 경우, 필요한 부분만 수평 확장이 가능하다.
3. 기술 스택 다양성
   - 서비스별 적합한 언어/프레임워크를 선택할 수 있다.
   - ex : 주문 서비스는 Java/Spring 조합, 추천 서비스는 Python, 고성능 API는 GO 등 선택적으로 기술 스택을 사용할 수 있다.
4. 장애 격리
   - 특정 서비스의 장애가 전체 시스템으로 전파되지 않고, 부분 장애로 제한된다.
5. 조직/개발 효율성
   - 서비스 단위로 팀을 나눌 수 있어서, 병렬적으로 개발하기에 용이하다.

#### 단점
1. 분산 시스템 복잡성
   - 서비스 간 통신, 데이터 일관성, 장애 대응, 네트워크 레이턴시 등 고려할 사항이 많다.
2. 운영 및 관리 비용 증가
   - 컨테이너, 서비스 디스커버리, 로깅, 모니터링, 트레이싱 등 운영 인프라가 필요하다.
3. 데이터 관리의 어려움
   - 서비스별로 DB 분리 -> 분산 트랜잭션 불가능
   - 결국 사가 패턴, 이벤트 소싱, eventual consistency 같은 패턴을 적용해야 한다.
4. 배포 및 테스트 복잡성
   - 단일 서비스 배포는 쉽지만, 시스템 통합 테스트는 어렵다.
   - 여러 서비스의 버전 호환성을 관리해야 하고, API 게약(Contract Testing)필요
5. 네트워크 비용 증가
   - 서비스 간 호출이 네트워크로 이뤄지므로 레이턴시 증가 + 트래픽 비용 부담

#### 정리
MSA는 대규모 시스템, 빠른 배포, 독립적 확장이 필요한 경우 장점이 두드러지지만, 초기 설계, 운영 복잡성이 크고, 작은 팀/작은 프로젝트에서는 오히려 독이 될 수 있다.

## 트랜잭션 관리
분산 환경에서 데이터 일관성, 실패 복구, 중복/순서/재처리 문제를 체계적으로 다루기 위한 설계 윈칙과 구현 패턴을 정의하고자 한다.

### 1. 트랜잭션 문제
이벤트 기반의 경우 트랜잭션 경계가 사라져서, 부분 실패·중복·순서·일시적 비일관성이 필연적으로 생긴다. 
이러한 문제가 생기는 이유는 아래와 같다.
- 서비스마다 로컬 트랜잭션만 있고, 교차 서비스는 비동기 메시징으로 연결하기 때문
- 브로커/네트워크/애플리케이션 레벨에서 부분 실패가 일어남
- 브로커는 보통 at-least-once 전달 -> 중복/순서 역전을 전제로 설계해야 한다.

그럼 전형적인 트랜잭션 문제에 대해서 알아보고자
1. 이중 쓰기(Dual-write) 문제
- 상황 : "DB 업데이트 + 이벤트 발행"을 애플리케이션 코드에서 같이 수행
- 증상 : 한쪽만 성공 (주문 저장 OK, 이벤트 발행 실패 or 그 반대)
- 대응 : 트랜잭셔널 Outbox(도메인 변경 + outbox insert를 같은 DB 트랜잭션으로 커밋) -> 별도 릴레이 브로커로 발행

2. 중복 처리 (Duplicates)
- 상황 : 프로듀서 재시도, 컨슈머 재처리, 릴레이가 보냈는데 마킹 실패 후 재발행 등
- 증상 : 재고 두 번 차감, 포인트 두 번 차감
- 대응 : 멱등 키 + UNIQUE 제약(DB) / Inbox 테이블로 컨슈머 측 idempotency 보장, 프로듀서는 enable.idempotence=true

3. 순서 역전 (Out-of-order)
- 상황 : 파티션 키가 불안정/다름, 멀티 파티션 사용, retry 이나 재균형 시
- 증상 : 같은 이벤트가 여러번 처리되어 순서가 꼬임 -> 결제 요청보다 재고 차감 이벤트가 먼저 도착
- 대응 : 키 기반 파티셔닝, 단일 흐름에선 단일 파티션 유지, 이벤트에 버전/시퀀스 포함 후 낮은 버전 무시/지연 처리

4. 메시지 유실/지연으로 인한 읽기-쓰기 불일치
- 상황 : 이벤트가 늦게 전달되거나 한동안 누락
- 증상 : UI/조회 모델이 최신 상태를 못 따라감(사용자는 주문 완료했는데 조회에 안 보임)
- 대응 : CQRS 리드 모델에 "동기화 상태 표시(스피너/배너)", 재처리 파이프라인 (DLQ->재주입), 지연 허용 UX

5. 컨슈머 오프셋 커밋 원자성 문제
- 상황 : 오프셋 커밋을 처리 전에 해버리거나, 처리 후 커밋 전에 장애
- 증상 : 유실(커밋 먼저) 또는 중복(커밋 전 장애)
- 대응 : "처리 -> 커밋" 순서로 하고, 가능하면 Inbox 트랜잭션과 묶어서 원자화. (배치라면 배치 단위 커밋)

6. 사가 보상 경쟁/과보상 (Race/Over-compensation)
- 상황 : 타임아웃으로 보상 시작 후, 늦은 `성공` 이벤트 도착
- 증상 : 재고 환원 + 포인트 환불까지 했는데, 나중에 성공 이벤트가 와서 상태 뒤엉킴
- 대응 : 상태 머신 + 상태 전이 가드(idempotent 보상), 각 단계 타임아웃/상태 만료 정의, "보상은 역순·멱등" 원칙

7. 키 설계·락 경쟁으로 인한 일관성 붕괴
- 상황 : 잘못된 파티션 키로 서로 다른 파티션에서 동일 집합을 갱신, 또는 단일 키 핫스팟
- 증상 : 순서 보장 실패/지연 급증
- 대응 : 정확한 Aggregate 키 선정(Ex: 주문 흐름은 항상 `orderId`), 필요 시 셔딩 + 재파티셔닝 전략

8. 운영/배포 과정의 '부분 업데이트'
- 상황 : 프로듀서/컨슈머 버전 미스매치, 롤링 배포 도중 계약 불일치
- 증상 : 일부 이벤트만 처리, 일부는 DLQ
- 대응 : 호환성 유지 점진 배포, 컨슈머 드레인(종료 전 폴 처리)

### 2. 실패 모델(Failure Taxonomy)와 대응
| 범주       | 예시                  | 영향                          | 대응                                      |
|----------|---------------------|-----------------------------|-----------------------------------------|
| 네트워크    | 타임아웃, 부분 실패         | 중복 발행/중복 소비, 순서 역전         | 재시도 + 백오프, 멱등 처리, DLQ                  |
| 애플리케이션 | 예외, 롤백              | 이벤트 누락/중복                  | 트랜잭셔널 아웃박스, 인박스 디듀프                   |
| 브로커     | 리더 선출, ISR 축소        | 일시 가용성 저하                   | acks=all, min.insync.replicas, 재시도         |
| 데이터     | 스키마 변경              | 역직렬화 실패                     | 스키마 버저닝, 호환성 정책                         |
| 운영      | 배포/롤백               | 중복 처리, 순서 불일치               | 소비자 버전 호환성, 컨슈머 드레인                     |

### 3. 트랜잭션 경계 정의
- 서비스 내부(Local) : `@Transactional` 블록에서 도메인 상태 변경 + Outbox 레코드 기록을 같은 DB 트랜잭션으로 커밋
- 서비스 간(Cross-service) : Outbox 레코드를 `비동기 릴레이(Outbox Relay`가 브로커로 발행. 소비 서비스는 Inbox 패턴으로 멱등 처리

결론 : 내부는 DB의 일관성 (ACID), 외부는 사가, 이벤트를 활용한 일관성

#### 4. 핵심 패턴
4-1. 트랜잭셔널 Outbox
동일 트랜잭션에서 DB 업데이트 + 메시지 발행을 수행한다면, 한쪽만 성공하는 위험이 있다. 그러므로 도메인 변경과 Outbox 테이브에 이벤트를 기록한 뒤 DB 커밋.
별도의 릴레이 프로세스가 Outbox를 폴링/스트링밍하여 브로커로 발행한다.

장점 : DB 커밋과 이벤트 기록이 원자적이고, 브로커 일시 장애에도 손실이 없다.
단점 : 폴링 지연/운영 컴포넌트(릴레이) 필요하다. CDC 대안 고려 가능

4-2. CDC (Change Data Capture) + Debezium(옵션)
Outbox 대신 CDC로 트랜잭션 로그에서 변경 이벤트를 캡처 -> Kafka Connect를 통해 토픽으로 전송

장점 : 앱 코드 단순화, 고성능
단점 : 인프라 복잡도 증가, 스키마/로그 접근 권한 요구

4-3. Inbox 패턴 (컨슈머 멱등 처리)
컨슈머 재시도·중복 수신 시 중복 적용의 위험이 있다.
이러한 경우 컨슈머가 처리한 이벤트 키를 Inbox 테이블에 기록 후, 이미 처리된 키는 무시한다.

4-4. Saga
- 코레오그래피 : 각 서비스가 이벤트에 반응하여 다음 이벤트를 발행한다. 단순/유연하지만 흐름 가시성이 낮고 복잡성이 증가한다.
- 오케스트레이션 : 중앙 오케스트레이터가 단계별 커멘드/이벤트를 주도한다. 가시성이 높지만 중앙 집중 컴포넌트에 의존하여 장애포인트가 된다.

#### 5. 테스트 전략
- 단위 테스트 : Outbox/Inbox 레포지토리, 멱등 로직, 보상 커맨드 매핑 테스트
- 통합 테스트 : Testcontainers(MySQL/Kafka)로 Outbox -> 브로커 -> Inbox 까지 E2E 테스트

## 마무리
MSA 전환은 항상 정답은 아니지만, 대규모 서비스의 유연성과 확장성을 확보하는 데 효과적인 아키텍처이다.
복잡한 구조이기에 다양한 문제가 발생할 수 있지만, 이 설계 문서를 통해 문제점을 인지하고 적절하게 대응한다면, MSA를 적용하는 것도 충분히 좋은 선택이라고 생각합니다.